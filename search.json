[{"title":"线性表","url":"/2020/03/25/线性表/","content":"## 特点\n    1.相同特性(方便批处理)\n    2.有限(个数有限)\n    3.序列(体现一对一的逻辑性)  \n        一对一:每个元素有一个前驱和后继\n\n## 存储结构\n    1.顺序存储\n        1.数组实现\n    2.链式存储\n        1.链表实现\n\n## 链表种类\n    1.单链表\n        1.带头节点\n            1.元素\n                1.头节点\n                2.开始结点(第一个存数据)\n            3.判空条件:Head->next == NULL\n        2.不带头节点\n            1.判空条件 Head == NULL\n    2.双链表\n    3.单循环链表\n        1.带头节点\n            1.判空条件:Head->next == Head\n        2.不带头节点\n            1.判空条件:Head == NULL\n    4.双循环链表\n        1.带头节点\n            1.判空条件:Head->prior = Head or Head->next = Head\n        2.不带头节点\n            1.判空条件:Head == NULL\n            \n            \n## 考点\n    1.特性对比问题\n    2.插入删除\n    3.建表\n    4.划分\n    5.归并\n    6.逆置\n    7.取最值\n    8.移动次数计算和静态链表\n    \n## 不同存储结构特性对比\n    1.插入删除\n        1.顺序表插入删除操作可能【尾部插入除外】会导致大量元素移动\n        2.链表插入删除不会导致大量移动\n    2.存取\n        1.顺序表:随机存取\n        2.单链表:从头到尾查找(不支持随机存取)\n            1.双链表循环链表可以从给定结点开始查找，仍然不支持随机存取\n            2.为经常定位的位置设定指针:如尾指针\n    3.存储空间\n        1.从整体来看，链表【一般】比顺序表节省空间\n        2.但是顺序表在满存的时候，利用率不一定比链表低\n        3.单个存储单元\n            1.顺序表无额外开销\n            2.链表有额外指针开销\n            3.顺序表单个存储空间利用率比链表高\n            \n## 移动次数计算和静态链表\n    1.插入操作移动次数的计算题型\n        1.某个位置插入元素所需要的移动次数\n        2.在每个位置上插入元素所需的评价移动次数\n            1.每个位置概率(大多数概率相同)\n            2.每个位置所需移动次数\n            3.Σ(概率*次数)\n        3.在位置i(0~n)位置插入，需要移动n-i个元素\n        4.平均移动n/2\n    2.删除操作移动次数计算\n        1.长度为n的可删除个数为n\n        2.每个概率评价为1/n\n        3.在i(0~n-1)位置,移动n-i-1\n        4.平均移动(n-1)/2\n        \n    3.静态链表\n        1.一次性分配完所需空间\n        2.结构体类型\n            typedef struct{\n                int data;\n                int next;// 存储下一个链表的\"地址\"[数组下标]\n            }SLNode;\n            SLNode SLink[maxSize];\n        3.基本操作\n            int p = Ad0 // 定义一个指针\n            SLink[p].data // 取指针p指向的结点值\n            SLink[p].next // 取p后继点指针\n            【在p后插入结点q】\n            SLink[q].next = SLink[p].next;\n            SLink[p].next = q;\n            \n## 插入与删除\n    1.链表插入与删除\n        1.单链表\n            1.插入\n                s->next = p->next;\n                p->next = s;\n            2.删除\n                p->next = s->next;\n                free(s)\n            3.特殊位置插入删除\n                1.含有头节点插入\n                    s-next = head->next\n                    head->next = s;\n                2.不含头节点插入\n                    s->next = head->next;\n                    head = s;  \n                3.含有头节点删除\n                    head->next = s->next;\n                    free(s);\n                4.不含头节点\n                    head = head->next;\n                    free(p);\n            4.总结\n                头节点:使得在第一个结点前后插入删除数据操作统一\n        2.双链表\n            1.插入\n                s->next = p->next;\n                p->next = s;\n                s->prior = p;\n                s->next->prior = s;\n            2.删除\n                s->prior->next = s->next;\n                s->next->prior = s->prior;\n                free(s);\n        3.顺序表\n            1.插入\n                1.可插入位置:0-length\n                2.length == maxSize不可插入\n                3.元素从后往前进行int sqList[maxSize] = {1, 2, 3,..n};\n                int length = n;\n                int insert(int sqList[],int &length, int p,int e){\n                    if(p<0 || p>length || lenght == maxSize)\n                        return 0;\n                    for(int i = length;i>p;i--)\n                        sqList[i] = sqList[i-1];\n                    sqList[p] = e;\n                    lenght ++;\n                    return 1;\n                }\n            2.删除\n                1.可删除范围0-length-1;\n                2.length=0,不可删除\n                3.元素从前往后进行\n                int remove(int sqList[], int &length, int p, int &e){\n                    if(p<0 || p>length-1 || length == 0)\n                    return 0;\n                    e = sqList[p];\n                    for(int i = p;i<length-1;i++)\n                        sqList[i] = sqList[i+1];\n                    length--;\n                    return 1; \n                }\n                \n## 建表\n    1.顺序表建表\n        int A[maxSize];\n        int length;\n        int creat(int A[],int &length){\n            std:cin>>length;\n            if(length > maxSize)\n                return 0;\n            for(int i=0;i<length;i++)\n                std::cin>>A[i];\n        }\n    2.链表建表算法\n        1.尾插法【单链表】链表顺序与输入顺序一致\n            void createLinkListR(LNode *&head){\n                head = (LNode*)malloc(sizeof(LNode);\n                head->next = NULL;\n                // 尾插法，在尾部进行操作，需要又要给指针维护尾部结点\n                // p指针指向插入结点，r指向尾部结点\n                LNode *p = NULL,*r = head;\n                int n = 0;\n                std::cin>>n; // scanf(\"%d\", &n);\n                for(int i = 0;i<n;i++){\n                    p = (LNode*)malloc(sizeof(LNode);\n                    p->next = NULL;\n                    std::cin>>p-<data;\n                    p->next = r->next;// 可不要\n                    r->next = p;\n                    r = p;\n                }\n            }\n        2.头插法：链表顺序与输入数据相反\n            void createLinkLiskH(LNode *&head){\n                head = (LNode *)malloc(sizeof(LNode);\n                head->next = NULL;\n                LNode *p = NULL;\n                int n;\n                std::cin>>n;\n                for(int i = 0;i<n;i++){\n                    P = (LNode *)malloc(sizeof(LNode));\n                    p->next = NULL;\n                    std::cin>>p->data;\n                    p->next = head->next;\n                    head->next = p;\n                }\n            }\n        3.真题:键盘输入n个英文字母，输入格式为n、C1、....Cn,其中n表示字母的个数，\n        请编程输入数据建立一个单链表，要求字母不重复存入链表\n            1.先遍历链表,遍历到尾部，如果没出现在尾部插入\n            void create(LNode &*head){\n                int n;\n                std::cin>>n;\n                head = (LNode *)malloc(sizeof(LNode);\n                LNode *p = NULL;\n                head->next = NULL;\n                for(int i = 0;i<n;i++){\n                    char c;\n                    std::cin>>c\n                    p = head->next;\n                    while(p!= NULL){\n                        if(p->data == c)\n                            break;\n                        p = p->next;\n                    }\n                    if(p == NULL){\n                        p = (LNode*)malloc(sizeof(LNode));\n                        p->data = ch;\n                        p->next = head->next;\n                        head->next = p;\n                    }\n                }\n                \n            }\n## 逆置\n    1.顺序表\n        // 奇数偶数代码实际上一样\n        for(int i =left, j = right;i<j;i++,j--){\n            temp = a[i];\n            a[i] = a[j];\n            a[j] = temp;\n        }\n    2.链表\n        // 逆置p->next 到q之间的结点\n        while(p->next != q){\n            t = p->next;\n            p->next = t->next;\n            t->next = q->next;\n            q->next = t;\n        }\n    3.真题:将一长度为n的数组的前端k(k<n)个元素逆序后移动到数组后端，要求数组中数据不丢失\n        void reverse(int a[],int left,int right,int k){\n            int temp;\n            for(int i = left,j = right,i<left + k && i < j; ++i,j--){\n                temp = a[i];\n                a[i] = a[j];\n                a[j] = temp;\n            }\n        }\n    真题:将一长度为n的数组的前端k(k<n)个元素保持原序后移动到数组后端，要求数组中数据不丢失\n        // 现在把前K个元素逆序，然后与后面逆序\n        void moveToEnd(int a[],int n,int k){\n            reverse(a,0,k-1,k);\n            reverse(a,0,n-1,k);\n        }\n    真题:将数组中(X0,X1,...Xn-1),经过移动后变为(Xp,Xp+1,...Xn-1,X0,X1....Xp-1)，即循环左移p个位置\n        //原数组 0-p-1的元素保持原序移到数组后\n        void moveP(int a[],int n,int p){\n            reverse(a,0,p-1,p);\n            reverse(a,p,n-1,n-p);\n            reverse(a,0,n-1,n);\n        }\n\n## 取最值\n    1.顺序表\n        // 最大值\n        int max = a[0];\n        int maxId = 0;\n        for(int i = 0;i < n; i++){\n            if(max < a[i]){\n                max = a[i];\n                maxId = i;\n            }\n        }\n        \n        // 找最小值\n        int min = a[0];\n        int minId = 0;\n        for(int i = 0;i < n; i++){\n            if(min > a[i]){\n                min = a[i];\n                minId = i;\n            }\n        }\n        \n    2.链表\n        // 取最大值\n        LNode *p, * q;\n        int max = head->next->data;\n        q = p = head->next;\n        while(p != NULL){\n            if(max < p->data){\n                max = p->data;\n                q = p;\n            }\n            p = p->next;\n        }\n        \n        // 找最小值\n        LNode *p, * q;\n        int min = head->next->data;\n        q = p = head->next;\n        while(p != NULL){\n            if(min < p->data){\n                min = p->data;\n                q = p;\n            }\n            p = p->next;\n        }\n    3.真题:一双链表非空，由head指针指出，结点结构为{llink,data,rlink}。请设计一个将结点数据与data值最大的哪个节点(最大值结点只有一个)移动到链表最前边的算法，要求不得申请新空间\n        void maxFirst(LNode *head){\n            // 找出最大值结点\n            LNode *p,*q;\n            p=q = head->rlink;\n            while(p!=NULL){\n                if(p->rlink->data > p->data){\n                    q = p->rlink;\n                }\n                p = p->rlink;\n            }\n            // “删除”结点\n            LNode *l = q->llink,*r = q->rlink;\n            l->link = r;\n            if(r != NULL)\n                r->llink = l;\n            // 插入\n            q->rlink = head->rlink;\n            q->llink = head;\n            head->rlink = q;\n            q->rlink->llink = q;\n        }\n        \n## 归并\n    1.顺序表\n        // 挑出最小元素，插入列表,直至一表结束，全部插入\n        void mergeArray(int a[],int m,int b[],int n,int c[]){\n            int i = 0,j = 0;\n            int k = 0;\n            while(i < m && j < n){\n                if(a[i] < b[j)\n                    c[k++] = a[i++];\n                else\n                    c[k++] = b[j++];\n            }\n            while(i < m){\n                c[k++] = a[i++];\n            }\n            while(j < n){\n                c[k++] = b[j++];\n            }\n        }\n    2.链表\n        void merge(LNode *A,LNode *B,LNode *&C){\n            LNode *p  = A->next;\n            LNode *q = B->next;\n            LNode *r;\n            \n            C = A;\n            C->next = NULL;\n            free(B);\n            r = C;\n            \n            while(p!=NULL && q!=NULL){\n                if(p->data <= q->data){\n                    r->next = p;\n                    p = p->next;\n                    r = r->next;\n                }\n                else{\n                    r->next = q;\n                    q = q->next;\n                    r = r>next;\n                }\n            }\n            if(q!=NULL)\n                r->next = q;\n            if(p!=NULL)\n                r->next = p;\n        }\n        \n        \n        // 归并后逆序\n        void merge(LNode *A,LNode *B,LNode *&C){\n            LNode *p  = A->next;\n            LNode *q = B->next;\n            LNode *s;\n            \n            C = A;\n            C->next = NULL;\n            free(B);\n            \n            while(p!=NULL && q!=NULL){\n                if(p->data <= q->data){\n                    s = p;\n                    p = p->next;\n                    s->next = C->next;\n                    C->next = s;\n                }\n                else{\n                    s = q;\n                    q = q->next;\n                    s->next = C->next;\n                    C->next = s;\n                }\n            }\n            while(p!=NULL){\n                s = p;\n                p = p->next;\n                s->next = C->next;\n                C->next =s;\n            }\n            while(q!=NULL){\n                s = q;\n                q = q->next;\n                s->next = C->next;\n                C->next = s;\n            }\n        }\n        \n## 划分\n    1.以某个元素为基准。划分为左右两部分\n    2.以第一个元素为轴,左边都<轴，右边都>轴\n        void partition(int a[], int n){\n            int temp = a[0];\n            int i = 0,j = n-1;\n            whilie(i < j){\n                // 从后往前找到比轴小的部分\n                // 每次移动，都需要保证i<j\n                while(i<j && arr[j] >=temp)\n                    j--;\n                // 搬运元素，\n                if(i < j){\n                    arr[i] = arr[j];\n                    i++;\n                }\n                while(i<j && arr[i] <= temp)\n                    i++;\n                if(i < j){\n                    arr[j] = arr[i];\n                    j--;\n                }\n            }\n        }\n    \n    3.额外找个比较的标准\n        void partition(int a[], int n,int comp){\n            int temp = a[0];\n            int i = 0,j = n-1;\n            whilie(i < j){\n                // 从后往前找到比轴小的部分\n                // 每次移动，都需要保证i<j\n                while(i<j && arr[j] >=comp)\n                    j--;\n                // 搬运元素，\n                if(i < j){\n                    arr[i] = arr[j];\n                    i++;\n                }\n                while(i<j && arr[i] <= comp)\n                    i++;\n                if(i < j){\n                    arr[j] = arr[i];\n                    j--;\n                }\n            }\n        }\n        \n    3.以数组中的任意位置为数轴划分\n        void partition(int a[], int n，int k){\n            int temp = a[0];\n            int i = 0,j = n-1;\n            arr[0] = arr[k];\n            arr[k] = temp\n            whilie(i < j){\n                // 从后往前找到比轴小的部分\n                // 每次移动，都需要保证i<j\n                while(i<j && arr[j] >=temp)\n                    j--;\n                // 搬运元素，\n                if(i < j){\n                    arr[i] = arr[j];\n                    i++;\n                }\n                while(i<j && arr[i] <= temp)\n                    i++;\n                if(i < j){\n                    arr[j] = arr[i];\n                    j--;\n                }\n            }\n        }   "},{"title":"git的使用","url":"/2019/11/14/git的使用/","content":"\n\n## github本地项目的初始配置\n\tcmd 切换到指定路径\n\t配置 git config --global user.name '账户名'\n\t配置 git config --global user.email 'b347996447@gmail.com'\t\n\t检查配置 git config -l\n\n\n## 本地关联到github项目\n\t1.当前目录下打  git init\n\t2.项目关联github git remote add origin + git@github.com:Yangzhenzhong1/blockchain.git(仓库链接)\n\n\n## 如何把本地的文件推送到git端\n\t1.git status 看本地发生哪些变化\n\t2.如何让文件修改在本地生效\n\t\t1.git add *\n\t\t2.git commit -m '注释'\n\t3.推送到git端\n\t\t1.git push -u origin master\n\t\t\n\t\n\t\n## 如何获得别人git项目\n\t1.搜索项目\n\t2.fork项目\n\t\n\n## 自己如何查看别人的修改并同意修改\n\tfork项目到本地后\n\t1.修改后点 commit changes\n\t2.项目pull request\n\t3.点击new pull request\n\t4.点击 create pull request\n\t5.pull request\n\t6.点击修改内容查看\n\t7.merge pull request  confirm merge 合并\n\n\n\n## hexo 使用\n\thexo s 开启博客\n\thexo new title 创建博客\n\thexo clean 清理重复文件\n\thexo d -g 同步到git端."}]